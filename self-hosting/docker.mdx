---
title: "Docker Deployment"
description: "Deploy Quackback using Docker. The fastest way to get to production."
icon: "docker"
---

# Docker Deployment

The fastest way to get Quackback into production. Docker handles dependencies, database setup, and migrations automatically.

## Prerequisites

- Docker Engine 20.10+
- Docker Compose v2+
- 1 GB RAM minimum (2 GB recommended)
- PostgreSQL 17+ (included in docker-compose, or bring your own)

## Quick Deploy

### Using Docker Compose (Recommended)

```bash
# Clone the repository
git clone https://github.com/quackbackio/quackback.git
cd quackback

# Configure environment
cp .env.example .env
# Edit .env with your settings (see Configuration below)

# Start services
docker compose up -d
```

### Using Docker Run

```bash
docker run -d \
  --name quackback \
  -p 3000:3000 \
  -e DATABASE_URL="postgresql://user:pass@host:5432/quackback" \
  -e SECRET_KEY="your-32-char-secret" \
  -e BASE_URL="https://feedback.yourcompany.com" \
  ghcr.io/quackbackio/quackback:latest
```

## How the Docker Image Works

The Quackback Docker image uses a multi-stage build:

- **Builder stage** compiles the application and installs dependencies
- **Production stage** runs as a non-root `quackback` user for security
- **Entrypoint** (`docker-entrypoint.sh`) runs database migrations automatically on every startup, then starts the server
- **Optional seeding** with `SEED_DATABASE=true` to populate demo data
- **Health endpoints** at `/api/health` (app) and `/api/ready` (app + database)

<Tip>
Because migrations run on every startup, upgrading is as simple as pulling the latest image and restarting. No manual migration step needed.
</Tip>

## Configuration

### Required Environment Variables

```bash
# Database connection
DATABASE_URL="postgresql://postgres:postgres@postgres:5432/quackback"

# Authentication (generate with: openssl rand -base64 32)
SECRET_KEY="your-32-character-minimum-secret-key"

# Public URL (must match your domain)
BASE_URL="https://feedback.yourcompany.com"
```

### Email Configuration

<Note>
Without email configuration, OTP codes are printed to the console. For production, configure one of the providers below.
</Note>

**SMTP (Recommended)**
```bash
EMAIL_SMTP_HOST="smtp.example.com"
EMAIL_SMTP_PORT="587"
EMAIL_SMTP_USER="your-username"
EMAIL_SMTP_PASS="your-password"
EMAIL_FROM="feedback@yourcompany.com"
```

**Resend**
```bash
EMAIL_RESEND_API_KEY="re_xxxxxxxxxxxx"
EMAIL_FROM="feedback@yourcompany.com"
```

### OAuth Providers (Optional)

```bash
# GitHub
GITHUB_CLIENT_ID="your-github-client-id"
GITHUB_CLIENT_SECRET="your-github-client-secret"

# Google
GOOGLE_CLIENT_ID="your-google-client-id"
GOOGLE_CLIENT_SECRET="your-google-client-secret"
```

### Integrations (Optional)

```bash
# Slack
SLACK_CLIENT_ID="your-slack-client-id"
SLACK_CLIENT_SECRET="your-slack-client-secret"
```

See [Environment Variables Reference](/docs/reference/environment-variables) for all options.

## Docker Compose Configuration

The included `docker-compose.yml` uses a custom PostgreSQL image with required extensions:

```yaml
services:
  postgres:
    build:
      context: ./docker/postgres
      dockerfile: Dockerfile
    container_name: quackback-db
    restart: unless-stopped
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
      POSTGRES_DB: quackback
    ports:
      - '5432:5432'
    volumes:
      - postgres_data:/var/lib/postgresql
    command: postgres -c shared_preload_libraries=pg_cron -c cron.database_name=quackback
    healthcheck:
      test: ['CMD-SHELL', 'pg_isready -U postgres']
      interval: 5s
      timeout: 5s
      retries: 5

volumes:
  postgres_data:
```

<Tip>
The custom Dockerfile (`docker/postgres/Dockerfile`) installs `pg_cron` and `pgvector` extensions on top of PostgreSQL.
</Tip>

## Database Setup

### Using the Included PostgreSQL

The docker-compose setup includes PostgreSQL with the required extensions (`pgvector`, `pg_cron`). Migrations run automatically when the container starts.

### Using an External Database

For managed databases (AWS RDS, Supabase, Neon, etc.):

1. Create a PostgreSQL 17+ database
2. Enable the `pgvector` extension
3. Set `DATABASE_URL` in your `.env`

Migrations run automatically when the Docker container starts, so no manual migration step is needed. If you need to run migrations outside of Docker:

```bash
docker run --rm \
  -e DATABASE_URL="your-external-db-url" \
  ghcr.io/quackbackio/quackback:latest \
  bun run db:migrate
```

## Reverse Proxy

In production, place a reverse proxy in front of Quackback for HTTPS. See the [Reverse Proxy Configuration](/docs/self-hosting/reverse-proxy) guide for Caddy, Nginx, and Traefik examples.

## Upgrading

<Warning>
Always back up your database before upgrading.
</Warning>

```bash
# 1. Back up your database
docker compose exec postgres pg_dump -U postgres quackback > backup.sql

# 2. Pull the latest image
docker compose pull

# 3. Restart (migrations run automatically)
docker compose up -d
```

Drizzle migrations are sequential and safe to re-run, so the container handles schema updates on startup without any manual steps.

### Rollback

If something goes wrong:

```bash
# Stop containers
docker compose down

# Restore the backup
docker compose up -d postgres
docker compose exec -T postgres psql -U postgres quackback < backup.sql

# Start with the previous image
docker compose up -d app
```

## Health Checks

```bash
# Application health
curl http://localhost:3000/api/health

# Ready check (includes database)
curl http://localhost:3000/api/ready
```

## Troubleshooting

### Container won't start

Check logs:
```bash
docker compose logs app
```

### Database connection failed

1. Verify PostgreSQL is healthy:
   ```bash
   docker compose ps
   ```

2. Test connection:
   ```bash
   docker compose exec postgres psql -U postgres -c "SELECT 1"
   ```

### Port already in use

```bash
# Find process using port 3000
lsof -i :3000

# Or change the port in docker-compose.yml
# ports:
#   - "8080:3000"
```

## Security

<Warning>
Follow these practices for production deployments.
</Warning>

1. **Use strong secrets** - Generate with `openssl rand -base64 32`
2. **Enable HTTPS** - Always use TLS in production
3. **Restrict database access** - Do not expose PostgreSQL publicly
4. **Back up regularly** - Automate database backups
5. **Keep updated** - Pull latest images regularly

## Next Steps

- [Configuration Reference](/docs/reference/environment-variables) - All environment variables
- [Reverse Proxy Setup](/docs/self-hosting/reverse-proxy) - SSL/TLS and proxy configurations
- [Troubleshooting](/docs/self-hosting/troubleshooting) - Common issues and solutions
